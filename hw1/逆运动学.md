# 1. 核心概念

* **位姿（pose）**：位置 + 姿态（朝向）。平面 2D 里常指 $(x, y)$ 或 $(x,y,\phi)$；三维 3D 里是位置 $(x,y,z)$ + 方向（旋转）。
* **自由度（DOF）**：可独立控制的关节数。2 个关节 = 2DOF。
* **工作空间**：手臂能覆盖的范围。超出这范围，**无解**。
* **冗余**：DOF 多于任务所需（比如 7 轴机械臂只要求末端位置 3 维），**解会有无穷多个**，需要“选一个更优的”（例如关节居中、能量小）。
* **雅可比（Jacobian）**：描述“微小转关节 → 末端微小位移”的线性映射矩阵。它像一个**速度放大器**：给它关节速度，就算出末端速度。
* **奇异位形（Singularity）**：某些姿态下，雅可比“失效”（秩掉了），会出现“怎么转关节末端也不朝目标方向动”的现象；数值法会不稳或需要极大关节变化。典型：2R 伸直成一条线。
* **多解**：同一末端目标，可能有“肘上/肘下”等多个关节解；项目里常选**离当前姿态最近**的那组，运动更平滑。

---

# 2. IK 的三条主路

1. **解析法（几何/代数，closed-form）**

   * 利用几何关系直接解方程，**能一次性算出所有离散解**（肘上/肘下等）。
   * 适合简单/特定构型（2R/3R、部分 6R）。
   * **优点**：快、准。**缺点**：不一定能推得出，对复杂/冗余结构很难。

2. **数值法（基于雅可比，迭代逼近）**

   * 用误差 $\mathbf{e} = \mathbf{x}_{目标}-\mathbf{x}(\mathbf{q})$，通过雅可比算关节增量，**一步步挪近**。
   * 常见：**雅可比转置（最简单）**、**伪逆/牛顿**、**阻尼最小二乘 DLS（奇异更稳）**。
   * **优点**：适用广、易加约束。**缺点**：需要迭代与调参，可能陷入局部不收敛。
```
雅可比转置：让末端误差转为关节参数的变化量，自适应步长会较好
伪逆：收敛快，奇异处会有问题
DLS：在最小二乘中加入正则项，会更稳定
```
3. **启发式（CCD/FABRIK）**

   * 不用微分，直接“拧关节让末端更接近目标”，**实现超简单**。
   * **优点**：好写好用。**缺点**：精度和约束能力有限。

> **怎么选？**
>
> * 构型简单、能推解析：**用解析法**
> * 一般机械臂/需要加限制（速度/关节限位/避奇异）：**用数值法（DLS/伪逆）**
> * 动画/骨骼快速摆姿：**CCD/FABRIK**足够

---

# 3. 以 2 关节平面臂为例

2R 平面臂、连杆长度 $L_1, L_2$，目标点 $(x, y)$。

* 末端到基座距离 $r=\sqrt{x^2+y^2}$。
* 若 $r > L_1+L_2$（太远）或 $r < |L_1-L_2|$（太近），**无解**。
* 有解时，第二关节角 $q_2$ 满足

  $$
  \cos q_2 = \frac{x^2+y^2 - L_1^2 - L_2^2}{2 L_1 L_2}
  $$

  因为 $\sin q_2=\pm\sqrt{1-\cos^2 q_2}$，就有两种：**肘上/肘下**。
* 有了 $q_2$，再用三角关系求 $q_1$。

---

# 4. 解析法示例（2R，返回肘上/肘下两组解）

```python
import math
from typing import List, Tuple

def ik_2r_analytic(x: float, y: float, L1: float, L2: float) -> List[Tuple[float, float]]:
    r2 = x*x + y*y
    if r2 > (L1 + L2)**2 or r2 < (L1 - L2)**2:
        return []  # 工作空间外，无解

    c2 = (r2 - L1*L1 - L2*L2) / (2*L1*L2)
    c2 = max(-1.0, min(1.0, c2))  # 数值夹紧
    s2 = math.sqrt(max(0.0, 1 - c2*c2))

    q2_up   = math.atan2( s2, c2)   # 肘上
    q2_down = math.atan2(-s2, c2)   # 肘下

    def solve_q1(q2):
        k1 = L1 + L2*math.cos(q2)
        k2 = L2*math.sin(q2)
        return math.atan2(y, x) - math.atan2(k2, k1)

    q1_up   = solve_q1(q2_up)
    q1_down = solve_q1(q2_down)
    return [(q1_up, q2_up), (q1_down, q2_down)]

# 小测试
if __name__ == "__main__":
    L1, L2 = 0.5, 0.4
    x, y = 0.6, 0.2
    print(ik_2r_analytic(x, y, L1, L2))
```


---

# 5. 数值法

把“末端没到目标”的误差 $\mathbf{e}=[x_{t}-x,\ y_{t}-y]$ 通过雅可比 $J$ 反推**关节应该往哪儿动**：

$$
\Delta \mathbf{q} = \alpha\,J^\mathsf{T}\,\mathbf{e}
$$

* $J$ 告诉你“**转关节→末端怎么动**”。
* 取一个不太大的步长 $\alpha$，不断迭代：

  1. 用当前 $q$ 做 **FK** 得到 $(x,y)$
  2. 算误差 $e$
  3. 求雅可比 $J$
  4. 更新 $q \leftarrow q + \alpha J^\mathsf{T} e$
  5. 误差够小就停；不行就继续

> 如果靠近奇异（比如手臂拉直），雅可比转置可能慢或抖；进一步可换 **DLS/伪逆**，会更稳。

**2R 的雅可比**（给位置 $(x,y)$）：

$$
\begin{aligned}
x &= L_1\cos q_1 + L_2\cos(q_1+q_2)\\
y &= L_1\sin q_1 + L_2\sin(q_1+q_2)
\end{aligned}
\Rightarrow
J=
\begin{bmatrix}
-\!L_1\sin q_1-\!L_2\sin(q_1+q_2) & -\!L_2\sin(q_1+q_2)\\
\ \ L_1\cos q_1+\ \ L_2\cos(q_1+q_2) & \ \ L_2\cos(q_1+q_2)
\end{bmatrix}
$$

---

# 6. 数值法示例（2R，雅可比转置迭代，带限位与收敛判断）

```python
import math
import numpy as np

def fk_2r(q1, q2, L1, L2):
    x = L1*math.cos(q1) + L2*math.cos(q1+q2)
    y = L1*math.sin(q1) + L2*math.sin(q1+q2)
    return np.array([x, y])

def jacobian_2r(q1, q2, L1, L2):
    s1, c1 = math.sin(q1), math.cos(q1)
    s12, c12 = math.sin(q1+q2), math.cos(q1+q2)
    J = np.array([
        [-L1*s1 - L2*s12, -L2*s12],
        [ L1*c1 + L2*c12,  L2*c12],
    ])
    return J

def ik_2r_jt(x_t, y_t, L1, L2,
             q_init=(0.0, 0.0),
             alpha=0.5,           # 步长（0.1~0.8 之间调）
             iters=200,
             tol=1e-5,
             q_min=(-math.pi, -math.pi),
             q_max=( math.pi,  math.pi)):
    q = np.array(q_init, dtype=float)
    target = np.array([x_t, y_t], dtype=float)

    # 可达性简单判断
    r = math.hypot(x_t, y_t)
    if r > L1 + L2 + 1e-9 or r < abs(L1 - L2) - 1e-9:
        return None, "目标在工作空间之外"

    for _ in range(iters):
        pos = fk_2r(q[0], q[1], L1, L2)
        e = target - pos
        if np.linalg.norm(e) < tol:
            return q, "OK"
        J = jacobian_2r(q[0], q[1], L1, L2)
        dq = alpha * (J.T @ e)
        q += dq
        # 关节限位（简单夹紧）
        q = np.minimum(np.maximum(q, np.array(q_min)), np.array(q_max))
    return q, "未收敛（可能接近奇异或步长不合适）"

# 小测试
if __name__ == "__main__":
    L1, L2 = 0.5, 0.4
    q_sol, info = ik_2r_jt(0.6, 0.2, L1, L2, q_init=(0, 0), alpha=0.4)
    print(info, "，解(度)=", None if q_sol is None else np.rad2deg(q_sol))
```

**调参建议**

* `alpha` 太小收敛慢，太大易抖；接近奇异时适当减小。
* 还不稳就改用 **DLS**：$\Delta q = J^\mathsf{T}(JJ^\mathsf{T}+\lambda^2 I)^{-1}e$。

---

# 7. 常见坑与简单对策

* **无解**（目标超出工作空间）：先做**可达性检查**；路径规划时避开。
* **奇异**（手臂拉直/折叠）：换 **DLS**、减小步长、绕开那点。
* **多解**（肘上/肘下）：**选离当前关节角最近的那组**，动作更连贯。
* **冗余**（解太多）：在零空间加“二级目标”（如关节居中、避碰）。
* **带姿态的目标**（$\phi$ 或 3D 姿态）：把位置误差和姿态误差拼在一起解，姿态误差的权重可以略低。

